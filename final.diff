diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..7e99e36
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+*.pyc
\ No newline at end of file
diff --git a/dh/__init__.py b/dh/__init__.py
index 6d6f182..43fc166 100644
--- a/dh/__init__.py
+++ b/dh/__init__.py
@@ -7,29 +7,46 @@ from lib.helpers import read_hex
 
 # 1536 bit safe prime for Diffie-Hellman key exchange
 # obtained from RFC 3526
+#4096-bit MODP Group
 raw_prime = """FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
-29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
-EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
-E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
-EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
-C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
-83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
-670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF"""
+      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
+      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
+      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
+      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
+      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
+      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
+      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
+      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
+      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
+      15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
+      ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
+      ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
+      F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
+      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
+      43DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7
+      88719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA
+      2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6
+      287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
+      1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
+      93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
+      FFFFFFFF FFFFFFFF"""
 # Convert from the value supplied in the RFC to an integer
 prime = read_hex(raw_prime)
+g = 2
 
 # Project TODO: write the appropriate code to perform DH key exchange
 
 def create_dh_key():
     # Creates a Diffie-Hellman key
     # Returns (public, private)
-    a = random.randint(0, int(2**8))
-    return (a, a)
+    private = random.randint(0, prime)
+    public = pow(g, private, prime)
+    return (public, private)
 
-def calculate_dh_secret(their_public, my_private):
+def calculate_dh_secret(public, private):
     # Calculate the shared secret
-    shared_secret = their_public * my_private
-
+    #pow is faster
+    shared_secret = pow(public,private,prime)
     # Hash the value so that:
     # (a) There's no bias in the bits of the output
     #     (there may be bias if the shared secret is used raw)
diff --git a/lib/comms.py b/lib/comms.py
index 3ed42bd..c3c46c9 100644
--- a/lib/comms.py
+++ b/lib/comms.py
@@ -1,9 +1,16 @@
 import struct
+import datetime
+import Random
+
+#from Crypto.Cipher import XOR
+from Crypto.Hash import HMAC
+from Crypto.Cipher import AES
 
-from Crypto.Cipher import XOR
 
 from dh import create_dh_key, calculate_dh_secret
 
+timestamp_len = 26 #Specifiying length of the string
+
 class StealthConn(object):
     def __init__(self, conn, client=False, server=False, verbose=False):
         self.conn = conn
@@ -11,6 +18,8 @@ class StealthConn(object):
         self.client = client
         self.server = server
         self.verbose = verbose
+        self.shared_hash = None 
+        self.last_time = datetime.datetime.now()
         self.initiate_session()
 
     def initiate_session(self):
@@ -26,20 +35,54 @@ class StealthConn(object):
             their_public_key = int(self.recv())
             # Obtain our shared secret
             shared_hash = calculate_dh_secret(their_public_key, my_private_key)
-            print("Shared hash: {}".format(shared_hash))
+            if self.verbose:
+                print("Shared hash: {}".format(self.shared_hash))
+            self.shared_hash = bytes.fromhex(self.shared_hash)
 
-        # Default XOR algorithm can only take a key of length 32
-        self.cipher = XOR.new(shared_hash[:4])
+        #AES in CBC Mode For Encryption
+        random_seed = (random.seed * self_shared)
+        iv = random.getrandbits(16) #Random Initialization vector
+        self.cipher = AES.new(self.shared_hash, AES.MODE_CBC, iv) #Creates The Cipher Object
 
-    def send(self, data):
+    def send (self, msg):
+        #Initialising string with "b" to indicate byte string. 
+        if type(msg) !=type(b""):
+            #bytes converter. 
+                msg = bytes(msg,'ascii')
+            #True or False 
+        if self.verbose:
+            print("Function 'Send' Recieved msg", msg,type(msg))
+            
+        #Creating a HMAC and additing it to the message.
+        if self.shared_hash !=None:
+            hmac= HMAC.new(self.shared_hash, msg = encrypted_data)
+            hmac.update(msg) #Added the message by updating Hash
+        #Compare Hexdigest of each hash
+        if self.verbose:
+                print("Hex Digest Is:", hmac.hexdigest())
+            mac = bytes(hmac.hexdigest() + msg.decode("ascii"), "acii")
+        else:
+            mac = msg
+        if self.verbose:
+            print("Msg is now encoded", mac, type(mac))
+        
+        #Timestamp
+        #Importing timestamp into the message
+        current_time = str (datetime.datetime.now()) #Formatted to string
+        mac = bytes(current_time,'ascii') + mac #Added to message
+        
+        def send(self, data):
         if self.cipher:
-            encrypted_data = self.cipher.encrypt(data)
+            encrypted_data = self.cipher.encrypt(mac) #Encrypt the message
             if self.verbose:
                 print("Original data: {}".format(data))
                 print("Encrypted data: {}".format(repr(encrypted_data)))
                 print("Sending packet of length {}".format(len(encrypted_data)))
         else:
-            encrypted_data = data
+            encrypted_data = mac
+            if self.verbose
+                print("Encrypted data is same as data",type(encrypted_data))
+                
 
         # Encode the data's length into an unsigned two byte int ('H')
         pkt_len = struct.pack('H', len(encrypted_data))
@@ -64,5 +107,37 @@ class StealthConn(object):
 
         return data
 
+    #Removing Timestamp
+    
+    stamp = str(data,[:timestamp_len],'ascii') #_len Returns the lenght of the string storing into data
+    data = data [timestamp_len:]
+
+    #Getting the HMAC & Verifying
+    if self.shared_hash != None:
+        hmac = HMAC.new(self.shared_hash)
+        hmac_msg = data [:hmac.digest_size*2] #HMAC OF THE MESSAGE
+        data = data [hmac.digest+size*2]#MSG part of the message
+        hmac.update(data)
+        if h.hexidigest() !=str(hmac, 'ascii'):
+            if self.verbose:
+                print("bad message")
+                print ("hmac from message is: ", str(hmac_msg, 'ascii'))
+                print ("hmac from digest:", hmac.hexdigest())
+                print ("no verfiication of message", data)
+            raise RuntimeError ("bad message: HMAC does not match")
+    
+    #Check Timestamp to see if it is valid
+    msg_time = str (datetime.datetime.now())
+    if self.verbose:
+        print(msg_time)
+    if msg_time <= self.last_time #If the timestamp is not newer than the current time it will raise the following error.
+    if self.verbose:
+        print("Breach in Timestamp")
+        print("timestamp is: ", stamp)
+    raise RuntimeError("Timestamp is not newer than the last one recived")
+    self.last_message_time = msg_time #Updates the message time.
+
+    return data
+    
     def close(self):
         self.conn.close()
diff --git a/pastebot.net/valuables.txt b/pastebot.net/valuables.txt
new file mode 100644
index 0000000..b5b58a2
--- /dev/null
+++ b/pastebot.net/valuables.txt
@@ -0,0 +1,2 @@
+Bitcoin: 3j04itE3cW21WlKY4DeXU49Q9C9HyOXfc0
+Username/Password: Stephen pqz49g4kgO
\ No newline at end of file
